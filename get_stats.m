% game1 payoff matrix given by b1, c1. Game 1 is high stakes.
% game2 payoff matrix given by b2, c2. Game 2 is default.

% strategy = 12 vals: 4 each for game1, game 2, and transition strategy.
% player 1's strategy = [p1 p2 x]. player 2's strategy is [q1 q2 y].

% returns stationary payoff, frac cooperation, and time in game 1 for both
% strategies.

function [payoffs, frac_coops, frac_game1] = ...
        get_stats(game1, game2, strategy1, strategy2)
    
    %% constants
    
    % payoff matrices for game 1 = high-stakes. Game 2 is default.
    b1=game1(1); 
    c1=game1(2);
    
    % payoff matrices for game 2. Transition to Game 1 only if both agree.
    b2=game2(1); 
    c2=game2(2);
    
    % player 1's strategy
    p1=strategy1(1:4);
    p2=strategy1(5:8);
    x =strategy1(9:12);

    % player 2's strategy
    q1=strategy2(1:4);
    q2=strategy2(5:8);
    y =strategy2(9:12);

   
    % f = underlying environment dynamics of transitioning given both agree
    f = @(a, b) a*b;
     
    % decompose strategy vectors into individual probabilities CC, CD, DC, and DD
    p1cc = p1(1);
    p1cd = p1(2);
    p1dc = p1(3);
    p1dd = p1(4);

    p2cc = p2(1);
    p2cd = p2(2);
    p2dc = p2(3);
    p2dd = p2(4);

    q1cc = q1(1);
    q1cd = q1(2);
    q1dc = q1(3);
    q1dd = q1(4);

    q2cc = q2(1);
    q2cd = q2(2);
    q2dc = q2(3);
    q2dd = q2(4);

    xcc = x(1);
    xcd = x(2);
    xdc = x(3);
    xdd = x(4);

    ycc = y(1);
    ycd = y(2);
    ydc = y(3);
    ydd = y(4);
    
    %% helper functions
    
    % converts b, c values into vector of payoff matrix values [R S T P]
    player1_game_vals = @(b, c) [(b-c); (-c); b; 0];
    player2_game_vals = @(b, c) [b-c; b; -c; 0];

    % computes payoff = dot product of stationary eigenvector and game values
    get_payoff = @(evec, game_vals) evec * game_vals;


    % define Q = transition matrix
    Q = [
          f(xcc, ycc)*p1cc*q1cc, ...
          f(xcc, ycc)*p1cc*(1 - q1cc), ...
          f(xcc, ycc)*(1 - p1cc)*q1cc, ...
          f(xcc, ycc)*(1 - p1cc)*(1 - q1cc), ...
          (1 - f(xcc, ycc))*p2cc* q2cc, ...
          (1 - f(xcc, ycc))*p2cc * (1 - q2cc), ...
          (1 - f(xcc, ycc)) * (1 - p2cc)*q2cc, ...
          (1 - f(xcc, ycc))* (1 - p2cc) * (1 - q2cc) ...
         ;
          f(xcd, ydc)*p1cd*q1dc, ...
          f(xcd, ydc)*p1cd*(1 - q1dc), ...
          f(xcd, ydc)*(1 - p1cd)*q1dc, ...
          f(xcd, ydc)*(1 - p1cd)*(1 - q1dc), ...
          (1 - f(xcd, ydc))*p2cd*q2dc, ...
          (1 - f(xcd, ydc))*p2cd*(1 - q2dc), ...
          (1 - f(xcd, ydc))*(1 - p2cd)*q2dc, ...
          (1 - f(xcd, ydc))*(1 - p2cd)*(1 - q2dc), ...
         ;
          f(xdc, ycd)*p1dc*q1cd, ...
          f(xdc, ycd)*p1dc*(1 - q1cd), ...
          f(xdc, ycd)* (1 - p1dc)*q1cd, ...
          f(xdc, ycd)*(1 - p1dc)*(1 - q1cd), ...
          (1 - f(xdc, ycd))*p2dc*q2cd, ...
          (1 - f(xdc, ycd))*p2dc*(1 - q2cd), ...
          (1 - f(xdc, ycd))*(1 - p2dc)* q2cd, ...
          (1 - f(xdc, ycd))*(1 - p2dc)*(1 - q2cd), ...
         ;
          f(xdd, ydd)*p1dd*q1dd, ...
          f(xdd, ydd)*p1dd*(1 - q1dd), ...
          f(xdd, ydd)*(1 - p1dd)*q1dd, ...
          f(xdd, ydd)*(1 - p1dd)*(1 - q1dd), ...
          (1 - f(xdd, ydd))*p2dd*q2dd, ...
          (1 - f(xdd, ydd))*p2dd*(1 - q2dd), ...
          (1 - f(xdd, ydd))*(1 - p2dd)*q2dd, ...
          (1 - f(xdd, ydd))*(1 - p2dd)*(1 - q2dd), ...
         ;
          f(xcc, ycc)*p1cc*q1cc, ...
          f(xcc, ycc)*p1cc*(1 - q1cc), ...
          f(xcc, ycc)*(1 - p1cc)*q1cc, ...
          f(xcc, ycc)*(1 - p1cc)*(1 - q1cc), ...
          (1 - f(xcc, ycc))*p2cc* q2cc, ...
          (1 - f(xcc, ycc))*p2cc * (1 - q2cc), ...
          (1 - f(xcc, ycc)) * (1 - p2cc)*q2cc, ...
          (1 - f(xcc, ycc))* (1 - p2cc) * (1 - q2cc), ...
         ; 
          f(xcd, ydc)*p1cd*q1dc, ...
          f(xcd, ydc)*p1cd*(1 - q1dc), ...
          f(xcd, ydc)*(1 - p1cd)*q1dc, ...
          f(xcd, ydc)*(1 - p1cd)*(1 - q1dc), ...
          (1 - f(xcd, ydc))*p2cd*q2dc, ...
          (1 - f(xcd, ydc))*p2cd*(1 - q2dc), ...
          (1 - f(xcd, ydc))*(1 - p2cd)*q2dc, ...
          (1 - f(xcd, ydc))*(1 - p2cd)*(1 - q2dc), ...
         ;
          f(xdc, ycd)*p1dc*q1cd, ...
          f(xdc, ycd)*p1dc*(1 - q1cd), ...
          f(xdc, ycd)* (1 - p1dc)*q1cd, ...
          f(xdc, ycd)*(1 - p1dc)*(1 - q1cd), ...
          (1 - f(xdc, ycd))*p2dc*q2cd, ...
          (1 - f(xdc, ycd))*p2dc*(1 - q2cd), ...
          (1 - f(xdc, ycd))*(1 - p2dc)* q2cd, ...
          (1 - f(xdc, ycd))*(1 - p2dc)*(1 - q2cd), ...
         ;
          f(xdd, ydd)*p1dd*q1dd, ...
          f(xdd, ydd)*p1dd*(1 - q1dd), ...
          f(xdd, ydd)*(1 - p1dd)*q1dd, ...
          f(xdd, ydd)*(1 - p1dd)*(1 - q1dd), ...
          (1 - f(xdd, ydd))*p2dd*q2dd, ...
          (1 - f(xdd, ydd))*p2dd*(1 - q2dd), ...
          (1 - f(xdd, ydd))*(1 - p2dd)*q2dd, ...
          (1 - f(xdd, ydd))*(1 - p2dd)*(1 - q2dd), ...
        ];

    % Q is stochastic, guranteed to have eigenvector v w/ eigenvalue 1
    % v satisfies M'v = v, i.e. (M' - I)v = 0.
    
    % largest magnitude = 1 -> lamda = 1 or -1, so get the 2 largest magnitudes
    % [V, D] = eigs(Q', 1);

    % in case we have eigenvalues 1 and -1, make sure we get the one w/val = 1
    % v = V(:,1);
    % if D(1,1) < 0 
    %    v = V(:,2);
    % end
    
    v = null(Q'-eye(size(Q)));
    
    % v = stationary dist., make it positive, L1 normalize, make into row
    v = abs(v)/norm(v, 1);
    v = v';

    p_game_vals = [player1_game_vals(b1, c1); player1_game_vals(b2, c2)];
    q_game_vals = [player2_game_vals(b1, c1); player2_game_vals(b2, c2)];

    p_payoff = get_payoff(v, p_game_vals);
    q_payoff = get_payoff(v, q_game_vals);
    
    % v = stationary proportion in states
    
    % player 1 cooperates in states 1CC, 1CD, 2CC, and 2CD
    frac_coop1 = v(1) + v(2) + v(5) + v(6);
    
    % player 2 cooperates in states 1CC, 1DC, 2CC, 2DC
    frac_coop2 = v(1) + v(3) + v(5) + v(7); 
    
    % frac in game1 = proportion of time in state 1CC, 1CD, 1DC, 1DD
    frac_game1 = sum(v(1:4)); % v is already normalized
    payoffs = [p_payoff q_payoff];
    frac_coops   = [frac_coop1 frac_coop2];
end